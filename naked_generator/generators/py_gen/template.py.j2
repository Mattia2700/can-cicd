from enum import IntEnum
from abc import ABC
from struct import pack, unpack
from collections import namedtuple

class Bitset(ABC):
    def __init__(self, size_bytes):
        self.__bitset = bytearray(size_bytes)

    def setBit(self, index, value):
        self.__bitset[index/8] &= ~(1 << index % 8)
        self.__bitset[index/8] |= (value << index % 8)
    
    def flipBit(self, index):
        self.__bitset[int(index/8)] ^= 1 << index % 8
    
    def getBit(self, index) -> bool:
        return self.__bitset[int(index/8)] & (1 << index % 8)

{%- for bitset in bitsets %}

class {{ bitset.name }}(Bitset):
    {%- for item_name, item_value in bitset.items %}
    {{ item_name }} = {{ item_value }}
    {%- endfor %}
    
    def __init__(self):
        super().__init__({{ bitset.size_bytes }})

{%- endfor %}

{%- for enum in enums %}
    
class {{ enum.name }}(IntEnum):
    {%- for item_name, item_value in enum.items %}
    {{ item_name }} = {{ item_value }}
    {%- endfor %}
    
{%- endfor %}

{% for struct in structs -%}
{%- set class_name = struct.name %}
# {{ class_name }}
class {{ class_name }}:
    {% set parameters = ", ".join(fill_padding(struct.fields.keys())) -%}
    struct = namedtuple("{{ class_name }}_struct", "{{ " ".join(struct.fields.keys()) }}", rename=True)
    schema = "{{ endianness_tag }}{{ format_string(struct.fields) }}"
    
    @staticmethod
    def serialize({{ parameters.replace("0x00, ", "") }}) -> bytes:
        return pack({{ class_name }}.schema, {{ parameters }})
    
    @staticmethod
    def deserialize(buffer: bytes) -> "{{ class_name }}.struct":
        return {{ class_name }}.struct._make(unpack({{ class_name }}.schema, buffer))
{% endfor -%}