// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_H_
#define FLATBUFFERS_GENERATED_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

struct ENC_L_FROM_ACU;

struct ENC_R_FROM_ACU;

struct ENC_C_FROM_ACU;

struct PEDALS_FROM_ATC;

struct PEDALS_FROM_ACU;

struct HV_VOLT;

struct HV_TEMP;

struct HV_CURR_ERR_WARN;

struct LV_STATUS;

struct LV_STATUS_JUDGE;

struct INV_R_TEMP;

struct INV_L_TEMP;

struct MOT_R_TEMP;

struct MOT_L_TEMP;

struct CAL_SET_MIN_MAX;

struct CAL_RESP;

enum Status {
  Status_OFF = 0,
  Status_PRECHARGE = 1,
  Status_ON = 2,
  Status_FATAL = 3,
  Status_MIN = Status_OFF,
  Status_MAX = Status_FATAL
};

inline const Status (&EnumValuesStatus())[4] {
  static const Status values[] = {
    Status_OFF,
    Status_PRECHARGE,
    Status_ON,
    Status_FATAL
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[5] = {
    "OFF",
    "PRECHARGE",
    "ON",
    "FATAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (flatbuffers::IsOutRange(e, Status_OFF, Status_FATAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) ENC_L_FROM_ACU FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  ENC_L_FROM_ACU()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ENC_L_FROM_ACU(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(ENC_L_FROM_ACU, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) ENC_R_FROM_ACU FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  ENC_R_FROM_ACU()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ENC_R_FROM_ACU(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(ENC_R_FROM_ACU, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) ENC_C_FROM_ACU FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  ENC_C_FROM_ACU()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ENC_C_FROM_ACU(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(ENC_C_FROM_ACU, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) PEDALS_FROM_ATC FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  PEDALS_FROM_ATC()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PEDALS_FROM_ATC(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(PEDALS_FROM_ATC, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) PEDALS_FROM_ACU FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  PEDALS_FROM_ACU()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PEDALS_FROM_ACU(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(PEDALS_FROM_ACU, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) HV_VOLT FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  HV_VOLT()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  HV_VOLT(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(HV_VOLT, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) HV_TEMP FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  HV_TEMP()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  HV_TEMP(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(HV_TEMP, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) HV_CURR_ERR_WARN FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  HV_CURR_ERR_WARN()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  HV_CURR_ERR_WARN(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(HV_CURR_ERR_WARN, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) LV_STATUS FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  LV_STATUS()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  LV_STATUS(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(LV_STATUS, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) LV_STATUS_JUDGE FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  LV_STATUS_JUDGE()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  LV_STATUS_JUDGE(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(LV_STATUS_JUDGE, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) INV_R_TEMP FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  INV_R_TEMP()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  INV_R_TEMP(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(INV_R_TEMP, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) INV_L_TEMP FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  INV_L_TEMP()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  INV_L_TEMP(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(INV_L_TEMP, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) MOT_R_TEMP FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  MOT_R_TEMP()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  MOT_R_TEMP(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(MOT_R_TEMP, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) MOT_L_TEMP FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  MOT_L_TEMP()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  MOT_L_TEMP(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(MOT_L_TEMP, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) CAL_SET_MIN_MAX FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  CAL_SET_MIN_MAX()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  CAL_SET_MIN_MAX(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(CAL_SET_MIN_MAX, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) CAL_RESP FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t current_;
  int8_t status_;
  int8_t padding0__;

 public:
  CAL_RESP()
      : current_(0),
        status_(0),
        padding0__(0) {
    (void)padding0__;
  }
  CAL_RESP(uint16_t _current, Status _status)
      : current_(flatbuffers::EndianScalar(_current)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t current() const {
    return flatbuffers::EndianScalar(current_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(CAL_RESP, 4);

#endif  // FLATBUFFERS_GENERATED_SCHEMA_H_
