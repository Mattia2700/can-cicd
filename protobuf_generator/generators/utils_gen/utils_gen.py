import jinja2 as j2
import os
import re

from ...lib.network import Network
from ...lib import utils
from ...schema import Schema, BitSet, Enum, Number


__UTILS_NETWORK_TEMPLATE_ = os.path.dirname(__file__) + "/network_utils_template.h.j2"


def generate(schema: Schema, network: Network, filename, utils_dir_network):
    types, structs, messages = __parse_schema(schema, network)

    with open(f"{utils_dir_network}/{filename}_utils.h", "w") as f:
        f.write(__generate_network_utils(filename, types, structs, messages))

def __generate_network_utils(filename, types, structs, messages):
    with open(__UTILS_NETWORK_TEMPLATE_, "r") as f:
        skeleton_py = f.read()

    code = j2.Template(skeleton_py).render(
        filename=filename,
        types=types,
        structs=structs,
        messages=messages,
        utils=utils,
        isinstance=isinstance,
        BitSet=BitSet,
        Enum=Enum,
        Number=Number
    )

    return code

def __parse_schema(schema: Schema, network: Network):
    # bitsets = [type for type in schema.types if isinstance(type, BitSet)]
    # enums = [type for type in schema.types if isinstance(type, Enum)]
    types = schema.types
    structs = schema.structs
    messages = {}
    for message_name, message_contents in network.get_messages().items():
        if message_contents.get("split_senders", False) == True: # Check if the message was generated by splitting senders
            message_name = re.sub(r'_\d+$', '', message_name) # Use regex to remove _<number> at the end of the name
        
        if not message_name in messages:
            messages[message_name] = []
            messages[message_name].append(message_contents["id"])
        else:
            messages[message_name].append(message_contents["id"])

    return types, structs, messages